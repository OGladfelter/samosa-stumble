// for tab navigation
function openTab(evt, tabID) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }
  document.getElementById(tabID).style.display = "block";
  evt.currentTarget.className += " active";
  if (tabID == "analysis") {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });

    Waypoint.enableAll();
  }
}


//////////////////////////////////////////////////////////
// Data prep
//////////////////////////////////////////////////////////

function readData() { 
  d3.csv("data/historical.csv").then(function(data) {
      // Get the min and max samosas from your data
      const minSamosas = d3.min(data, d => d.samosas);
      const maxSamosas = d3.max(data, d => d.samosas);

      // Create color scale based on samosas range
      const rankColorScale = d3.scaleLinear()
        .domain([minSamosas, maxSamosas])
        .range(["#8181df", "#333399"]);
      
      // Convert samosas to numbers and sort by samosas (descending)
      data.forEach(d => {
        d.samosas = +d.samosas; // Convert to number
        d.miles = +d.miles;     // Convert miles to number too
        d.year = +d.year;       // Convert year to number
        d.rowColor = rankColorScale(d.samosas);
      });
      
      // Sort by samosas in descending order (most samosas first)
      data.sort((a, b) => b.samosas - a.samosas);
      
      // Add rank column
      let currentRank = 1;
      let previousSamosas = null;
      let sameRankCount = 0;
      
      data.forEach((d, i) => {
        if (previousSamosas !== null && d.samosas < previousSamosas) {
          currentRank += sameRankCount;
          sameRankCount = 1;
        } else if (previousSamosas === d.samosas) {
          sameRankCount++;
        } else {
          sameRankCount = 1;
        }
        
        d.participantID = i;
        d.rank = currentRank;
        previousSamosas = d.samosas;
      });
    
      // add each player to leaderboard
      data.forEach(d => {
        addRow(d.rank, d.name, d.samosas, d.year, d.rowColor, d);
      });
      
      // add some viz
      drawHeatmap(data); // draw heatmap
  }); 
};

//////////////////////////////////////////////////////////
// Leaderboard
//////////////////////////////////////////////////////////

function addRow(rank, name, samosas, year, rowColor, d) {
    var table = document.getElementById("leaderboardTable");
    var row = table.insertRow(-1);
    row.id = "leaderboardRow" + d.participantID;
    row.classList.add('leaderboardRow');

    var rankCell = row.insertCell(0);
    var nameCell = row.insertCell(1);

    if (screen.width >= 600) {
      var distanceCell = row.insertCell(2);
      var accuracyCell = row.insertCell(3);
      distanceCell.style.textAlign = 'right';
      distanceCell.innerHTML = samosas;
    }
    else {
      var accuracyCell = row.insertCell(2);
    }
    accuracyCell.style.textAlign = 'right';
    accuracyCell.innerHTML = Math.round(year);

    rankCell.innerHTML = '<span class="circle">' + rank + '</span>';
    nameCell.innerHTML = name;

    // make winners stand out
    if ((name == "Oliver Gladfelter" && year == 2023) || (name == "Jason Sikora" && year == 2024) || (name == "Ian McLeod" && year == 2022)) {
      nameCell.innerHTML += " &#129351;";
    }

    row.style.backgroundColor = rowColor;

    nameCell.style.textAlign = 'left';
    nameCell.style.fontSize = '18px';

    // add interactions for rows in leaderboard
    row.addEventListener("mouseover", function() {
        console.log(this);
    });
    row.addEventListener("mouseout", function() {
      console.log("out");
    });
    row.addEventListener("click", function() { // click a row to show their line in Standings Over Time tab
      document.getElementById('lineplotRow' + d.participantID).click();
      console.log('click');
    });
}

//////////////////////////////////////////////////////////
// Heatmap functions
//////////////////////////////////////////////////////////

function drawHeatmap(predictionsData) {

  // read heatmap data generated by python script
  d3.csv("data/heatmapData.csv").then(function(data) {
    
    const years = [2022, 2023, 2024];

    // Calculate total samosas for each person and sort by highest total
    data.forEach(d => {
      d.total = years.reduce((sum, year) => sum + parseInt(d[year]), 0);
    });
    
    // Sort by total samosas (descending - highest first)
    data.sort((a, b) => b.total - a.total);
    
    const stumblers = data.map(function(d) { return d.name}); // list candidates sorted by total samosas


    // reformat data into long format
    const heatmapData = [];
    data.forEach(d => {
      years.forEach(year => {
        heatmapData.push({name: d.name, year: year, value: parseInt(d[year])})
      });
    });

    // set the dimensions and margins of the graph
    var margin = {top: 100, right: 0, bottom: 10, left: 180},
        width = screen.width - 150 - margin.left - margin.right,
        height = screen.height - 150 - margin.top - margin.bottom;

    if (screen.width < 600) {
        margin = {top: 100, right: 30, bottom: 10, left: 70},
        width = (screen.width * .95) - margin.left - margin.right,
        height = (screen.width * .95) - margin.top - margin.bottom;
    }

    // Ensure reasonable sizing based on data dimensions
    // Width should accommodate years (3 columns)
    const minCellWidth = 80;
    const minCellHeight = 25;
    
    width = Math.max(width, years.length * minCellWidth);
    height = Math.max(height, stumblers.length * minCellHeight);

    var padding = 0.05;

    // append the svg object to the body of the page
    var svg = d3.select("#heatmap")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Build X scales and axis:
    var x = d3.scaleBand()
        .domain(years)
        .range([ 0, width ])
        .padding(padding);
    svg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(0,0)")
        .call(d3.axisTop(x));
    
    // Build Y scales and axis:
    var y = d3.scaleBand()
        .domain(stumblers)
        .range([ 0, height ])
        .padding(padding);
    svg.append("g")
        .attr("class", "axis")
        .attr('transform', 'translate(0, 0)')
        .call(d3.axisLeft(y));
    
    // grab the heatmap tooltip
    const heatmapTooltip = d3.select("#heatmapTooltip");
    var mousemove = function(event, d) {

        heatmapTooltip.style("opacity", d.value == 0 ? 0 : 1);
      
        heatmapTooltip
            .html(d.name + " ate<br> " + d.value + " samosas in " + d.year)
            .style('left', event.pageX / window.innerWidth <= 0.5 ? event.clientX + 20 + "px" : event.clientX - heatmapTooltip.node().getBoundingClientRect().width + 25 + 'px')
            .style('top', y(d.name) + heatmapTooltip.node().getBoundingClientRect().height + 25 + "px")
            .style('display', 'block');
    }

    // Build color scale for cells
    var heatmapColors = d3.scaleLinear()
      .domain(d3.extent(heatmapData, function(d) { return (d.value); }))
      .range(["#312e2b", "cyan"]); // from background color of charcoal to less-light cyan
      
    // draw and color the cells
    svg.selectAll()
        .data(heatmapData)
        .enter()
        .append("rect")
        .attr("id", function(d) { return d.name.replaceAll(" ","") + d.year + "Rect"})
        .attr("y", function(d) { return y(d.name) })
        .attr("x", function(d) { return x(d.year) })
        .attr("width", x.bandwidth() )
        .attr("height", y.bandwidth() )
        .style("fill", function(d) {return heatmapColors(d.value)} )
        //.style('cursor', function(d) { return d.value > 0 ? 'pointer' : 'default' })
        // .on("mouseover", function(d, data) {
        //   heatmapTooltip.style("opacity", 1);
        //   // if (data.value > 0) {
        //   //   d3.select(this).style("fill", "orange");
        //   // }
        // })
        .on("mousemove", mousemove)
        // .on("mouseleave", function() {
        //   heatmapTooltip.style("opacity", 0);
        //   //d3.select(this).style("fill", function(d) {return heatmapColors(d.value)} );
        // });

    // svg.append('rect')
    //     .attr("y", function(d) { return y('ramaswamy') })
    //     .attr("x", function(d) { return x(1) })
    //     .attr("width", width - 5)
    //     .attr("height", height / data.length )
    //     .style('fill', 'none')
    //     .style('stroke', 'orange')
    //     .style('stroke-width', '2px')
    //     .style('display', 'none')
    //     .attr('id', 'ramaswamyHighlightRect');

    // Build color scale for text label
    var textColor = d3.scaleQuantile()
      .domain(d3.extent(heatmapData, function(d) { return (d.value); })) // pass only the extreme values to a scaleQuantizeâ€™s domain
      .range(["white", "white", "white", "black"])

    // labels for squares
    svg.selectAll(".heatmapLabel")
        .data(heatmapData)
        .enter()
        .append("text")
        .text(function(d) { return d.value == 0 ? "" : d.value; })
        .attr("y", function(d) { return y(d.name) + (y.bandwidth() / 2) }) 
        .attr("x", function(d) { return x(d.year) + (x.bandwidth() / 2) }) 
        .style("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .attr('class', 'heatmapLabel')
        .style("fill", function(d) { return textColor(d.value)})
        .attr('pointer-events', 'none');
            
    // text label for the x axis
    // svg.append("text")             
    //     .attr("transform", "translate(" + (width/2) + " ," + (0 - (margin.top / 3)) + ")")
    //     .style("text-anchor", "middle")
    //     .attr('class', 'heatmapLabel')
    //     .text("Year");

    addWaypointInteractions(heatmapColors);

  });
}

function highlightLeaderboardRows(data, dropPosition, candidateName) {
    document.querySelectorAll('.leaderboardRow').forEach(d => d.classList.remove('orangeFill'));
    const theGuessers = data.filter(t => t.prediction[dropPosition] == candidateName);
    theGuessers.forEach(g => document.getElementById("leaderboardRow" + g.participantID).classList.add('orangeFill'));
    openTab(event, 'Leaderboard');
}

// for the heatmap and analysis bits
function addWaypointInteractions(colorScale) {

  // highlight trump circle
  const step1 = new Waypoint({
    element: document.getElementById('step1'),
    handler: function(direction) {
        if (direction == 'down') {
          // Paul F on
          highlightTile("#PaulFortunato2023Rect");
          highlightTile("#PaulFortunato2024Rect");
        }
        else {
          deHighlightTile("#PaulFortunato2023Rect", colorScale);
          deHighlightTile("#PaulFortunato2024Rect", colorScale);
        }
    },
    offset: 'bottom-in-view'
  });

  const step2 = new Waypoint({
    element: document.getElementById('step2'),
    handler: function(direction) {
        if (direction == 'down') {
          deHighlightTile("#PaulFortunato2023Rect", colorScale);
          deHighlightTile("#PaulFortunato2024Rect", colorScale);
          const consistentStumblers = ["IanMcLeod", "NathanGray", "CoreyHaines", "ChristyChiappone", "BrookeAngell", "RenaCeron", "NoelleRose"];
          const years = ["2022", "2023", "2024"];
          consistentStumblers.forEach(name => {
            years.forEach(year => {
              highlightTile("#" + name + year + "Rect");
            })
          });
        }
        else {
          const consistentStumblers = ["IanMcLeod", "NathanGray", "CoreyHaines", "ChristyChiappone", "BrookeAngell", "RenaCeron", "NoelleRose"];
          const years = ["2022", "2023", "2024"];
          consistentStumblers.forEach(name => {
            years.forEach(year => {
              deHighlightTile("#" + name + year + "Rect", colorScale);
            })
          });
          highlightTile("#PaulFortunato2023Rect");
          highlightTile("#PaulFortunato2024Rect");
        }
    },
    offset: 'bottom-in-view'
  });

  new Waypoint({
    element: document.getElementById('step3'),
    handler: function(direction) {
        if (direction == 'down') {
          highlightTile("#CraigWoods2022Rect");
          const consistentStumblers = ["IanMcLeod", "NathanGray", "CoreyHaines", "ChristyChiappone", "BrookeAngell", "RenaCeron", "NoelleRose"];
          const years = ["2022", "2023", "2024"];
          consistentStumblers.forEach(name => {
            years.forEach(year => {
              deHighlightTile("#" + name + year + "Rect", colorScale);
            })
          });
        }
        else {
          deHighlightTile("#CraigWoods2022Rect", colorScale);
          const consistentStumblers = ["IanMcLeod", "NathanGray", "CoreyHaines", "ChristyChiappone", "BrookeAngell", "RenaCeron", "NoelleRose"];
          const years = ["2022", "2023", "2024"];
          consistentStumblers.forEach(name => {
            years.forEach(year => {
              highlightTile("#" + name + year + "Rect");
            })
          });
        }
    },
    offset: 'bottom-in-view'
  });
  
  Waypoint.disableAll();
}

function highlightTile(id) {
  d3.select(id).style("fill", "orange").style("stroke", 'black').style("stroke-width", '1px');
}
function deHighlightTile(id, colorScale) {
  const thisData = d3.select(id).data()[0];
  d3.select(id).style("fill", colorScale(thisData.value)).style("stroke", 'none');
}

readData();